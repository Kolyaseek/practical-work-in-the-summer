import argparse
import asyncio
import logging
import sys
import time
import json
from aiortc import RTCIceCandidate, RTCPeerConnection, RTCSessionDescription, RTCConfiguration, RTCIceServer
from aiortc.contrib.signaling import BYE, add_signaling_arguments, create_signaling

logging.basicConfig(level=logging.DEBUG)
def channel_log(channel, t, message):
    print("channel(%s) %s %s" % (channel.label, t, message))
def channel_send(channel, message):
    channel_log(channel, ">", message)
    channel.send(message)
async def consume_signaling(pc, signaling):
    while True:
        obj = await signaling.receive()
        if isinstance(obj, RTCSessionDescription):
            await pc.setRemoteDescription(obj)
            if obj.type == "offer":
                await pc.setLocalDescription(await pc.createAnswer())
                await signaling.send(pc.localDescription)
        elif isinstance(obj, RTCIceCandidate):
            await pc.addIceCandidate(obj)
        elif obj is BYE:
            print("Exiting")
            break
        elif isinstance(obj, dict) and "candidate" in obj and "sdpMid" in obj and "sdpMLineIndex" in obj:
            candidate = RTCIceCandidate(sdpMid=obj["sdpMid"], sdpMLineIndex=obj["sdpMLineIndex"], candidate=obj["candidate"])
            await pc.addIceCandidate(candidate)
time_start = None
def current_stamp():
    global time_start
    if time_start is None:
        time_start = time.time()
        return 0
    else:
        return int((time.time() - time_start) * 1000000)
async def send_message(channel):
    while True:
        message = input("Enter message to send: ")
        channel_send(channel, message)
async def run_answer(pc, signaling):
    await signaling.connect()
    @pc.on("datachannel")
    def on_datachannel(channel):
        channel_log(channel, "-", "created by remote party")
        @channel.on("message")
        def on_message(message):
            channel_log(channel, "<", message)
            if isinstance(message, str) and message.startswith("ping"):
                channel_send(channel, "pong" + message[4:])
            else:
                print("Received message:", message)
        asyncio.ensure_future(send_message(channel))
    await consume_signaling(pc, signaling)
async def run_offer(pc, signaling):
    await signaling.connect()
    
    
    

    channel = pc.createDataChannel("chat")
    channel_log(channel, "-", "created by local party")
    async def send_pings():
        while True:
            channel_send(channel, "ping %d" % current_stamp())
            await asyncio.sleep(1)
    @channel.on("open")
    def on_open():
        asyncio.ensure_future(send_pings())
        asyncio.ensure_future(send_message(channel))
    @channel.on("message")
    def on_message(message):
        channel_log(channel, "<", message)
        if isinstance(message, str) and message.startswith("pong"):
            elapsed_ms = (current_stamp() - int(message[5:])) / 1000
            print(" RTT %.2f ms" % elapsed_ms)
        elif isinstance(message, str):
            print(" --- ", message)
    await pc.setLocalDescription(await pc.createOffer())
    await signaling.send(pc.localDescription)
    await consume_signaling(pc, signaling)
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Data channels ping/pong")
    parser.add_argument("role", choices=["offer", "answer"])
    parser.add_argument("--verbose", "-v", action="count")
    add_signaling_arguments(parser)
    args = parser.parse_args()
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    signaling = create_signaling(args)
    # Установка ICE серверов через конструктор RTCPeerConnection
    config = RTCConfiguration(iceServers=[RTCIceServer(urls=['stun:stun.l.google.com:19302'])])
    if args.role == "offer":
        pc = RTCPeerConnection(configuration=config)
        coro = run_offer(pc, signaling)
    else:
        pc = RTCPeerConnection(configuration=config)
        coro = run_answer(pc, signaling)
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(coro)
    except KeyboardInterrupt:
        pass
    finally:
        loop.run_until_complete(pc.close())
